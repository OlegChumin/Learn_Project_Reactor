package projects_reactor_lets_code;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * Реактивный поток представляет собой концепцию в реактивном программировании, которая обозначает
 * асинхронный поток данных, появляющихся в различных моментах времени. Он служит для представления
 * потока событий, изменений или данных в асинхронной и реактивной архитектуре.
 *
 * Основные характеристики реактивных потоков:
 *
 * Асинхронность: Реактивные потоки предоставляют асинхронные операции. Это позволяет эффективно
 * обрабатывать данные и события без блокирования потока выполнения.
 *
 * Поток данных: Реактивный поток представляет собой последовательность данных, которая может
 * включать в себя как синхронные, так и асинхронные события.
 *
 * Обратная связь (Backpressure): Реактивные потоки могут управлять обратной связью, что позволяет
 * управлять потоком данных в случае, когда производительность и потребление данных несбалансированы.
 * Это предотвращает переполнение и помогает эффективному управлению ресурсами.
 *
 * Операции над потоками: Реактивные библиотеки предоставляют богатый набор операций для
 * манипулирования реактивными потоками, такие как фильтрация, отображение, объединение, разделение
 * и др.
 *
 * Ленивая загрузка: Реактивные потоки обычно используют ленивую загрузку, что означает, что данные
 * обрабатываются только тогда, когда они запрашиваются (принцип "push" данных).
 *
 * Примеры реактивных библиотек в Java включают Project Reactor, RxJava, Akka Streams и другие. Они
 * предоставляют средства для создания, манипулирования и обработки реактивных потоков в
 * приложениях, что особенно полезно в асинхронном и распределенном программировании.
 */
public class Main {
    public static void main(String[] args) {
        Mono.empty(); // Эта строка создает пустой Mono. Это моно поток данных, который не содержит элементов.
        Flux.empty(); // Аналогично предыдущей строке, создает пустой Flux. Это поток данных, не содержащий элементов.
        Mono<Integer> mono = Mono.just(1); //поток данных Mono, который содержит ноль или один элемент
        Flux<Integer> flux = Flux.just(1, 2, 3, 4, 5); //Создается Flux<Integer>, который содержит
        // последовательность элементов от 1 до 5.

        Flux<Integer> fluxFromMono = mono.flux(); // Создается новый Flux<Integer> из существующего Mono<Integer>.

        Mono<Boolean> monoFromFlux = flux.any(element -> element.equals(1));
        // Создается Mono<Boolean>,
        // который содержит результат проверки условия. В данном случае, он проверяет, содержит ли flux хотя бы
        // один элемент, равный числу 1.

        /**
         * Когда вызывается метод .blockFirst(), он блокирует текущий поток выполнения, ожидая получения первого
         * элемента, удовлетворяющего условию фильтрации. Если такой элемент найден, метод возвращает его значение
         * типа Integer. Если поток пуст или элементы не соответствуют условию, метод возвращает null.
         *
         * Аналогично, метод .blockLast() блокирует текущий поток выполнения, ожидая получения последнего элемента,
         * удовлетворяющего условию фильтрации. Если такой элемент найден, метод возвращает его значение типа Integer.
         * Если поток пуст или элементы не соответствуют условию, метод возвращает null.
         */

        Integer resultFirst = flux.filter(element -> element.equals(1)).blockFirst();
        Integer resultLast = flux.filter(element -> element.equals(1)).blockLast();

        //.blockFirst(): Блокирует и возвращает первый элемент из потока, если он присутствует. Если поток пуст,
        // возвращает null.
        // .blockLast(): Блокирует и возвращает последний элемент из потока, если он присутствует.
        // Если поток пуст, возвращает null.



    }
}
